From c22551728892275cd749c847895de13c1d3cb43d Mon Sep 17 00:00:00 2001
From: No767 <73260931+No767@users.noreply.github.com>
Date: Sun, 27 Mar 2022 22:50:16 -0700
Subject: [PATCH] Double Check Everything + Bump Version to v2.0.0

---
 Bot/Cogs/deviantart.py       |   4 +-
 Bot/Cogs/discord-bots.py     |   4 +-
 Bot/Cogs/first-frc-events.py |  12 +-
 Bot/Cogs/hypixel.py          |   9 +-
 Bot/Cogs/mcsrvstats.py       |   8 +-
 Bot/Cogs/qrcode.py           | 100 ++---
 Bot/Cogs/reddit.py           | 684 +++++++++++++++++------------------
 Bot/Cogs/rininfo.py          |   2 +-
 Bot/Cogs/spiget.py           |   4 +-
 Bot/Cogs/top-gg.py           |   6 +-
 Bot/Cogs/version.py          |   2 +-
 Bot/Cogs/waifu-pics.py       |   4 +-
 Bot/Cogs/youtube.py          |   6 +-
 Bot/rinbot.py                |   3 +-
 14 files changed, 424 insertions(+), 424 deletions(-)

diff --git a/Bot/Cogs/deviantart.py b/Bot/Cogs/deviantart.py
index f715e14..c059861 100644
--- a/Bot/Cogs/deviantart.py
+++ b/Bot/Cogs/deviantart.py
@@ -68,7 +68,7 @@ class DeviantArtV1(commands.Cog):
                     color=discord.Color.from_rgb(255, 214, 214))
                 try:
                     if r.status == 200:
-                        filter = [
+                        filterItem = [
                             "author",
                             "stats",
                             "preview",
@@ -81,7 +81,7 @@ class DeviantArtV1(commands.Cog):
                         authorFilterMain = [
                             "type", "is_subscribed", "usericon"]
                         for keys, values in deviationMain.items():
-                            if keys not in filter:
+                            if keys not in filterItem:
                                 embedVar.add_field(
                                     name=keys, value=values, inline=True)
                         for k, v in deviationMain["author"].items():
diff --git a/Bot/Cogs/discord-bots.py b/Bot/Cogs/discord-bots.py
index 752c499..31cc761 100644
--- a/Bot/Cogs/discord-bots.py
+++ b/Bot/Cogs/discord-bots.py
@@ -83,11 +83,11 @@ class DiscordBotsV2(commands.Cog):
         description="Searches for any Discord Bots listed on discord.bots.gg via the Discord Bot's ID",
         guild_ids=[866199405090308116],
     )
-    async def discordBotsID(self, ctx, *, id: Option(str, "The ID of the Discord Bot")):
+    async def discordBotsID(self, ctx, *, bot_id: Option(str, "The ID of the Discord Bot")):
         async with aiohttp.ClientSession(json_serialize=orjson.dumps) as session:
             headers = {"Authorization": apiKey}
             async with session.get(
-                f"https://discord.bots.gg/api/v1/bots/{id}", headers=headers
+                f"https://discord.bots.gg/api/v1/bots/{bot_id}", headers=headers
             ) as response:
                 data2 = await response.content.read()
                 dataMain2 = orjson.loads(data2)
diff --git a/Bot/Cogs/first-frc-events.py b/Bot/Cogs/first-frc-events.py
index 9ff5766..8ae306b 100644
--- a/Bot/Cogs/first-frc-events.py
+++ b/Bot/Cogs/first-frc-events.py
@@ -34,12 +34,12 @@ class FirstFRCV1(commands.Cog):
             ) as r:
                 data = await r.content.read()
                 dataMain = orjson.loads(data)
-                filter = ["frcChampionships", "gameName"]
+                filterSeason = ["frcChampionships", "gameName"]
                 embedVar = discord.Embed()
                 embedError = discord.Embed()
                 try:
                     for k, v in dataMain.items():
-                        if k not in filter:
+                        if k not in filterSeason:
                             embedVar.add_field(name=k, value=v, inline=True)
                     for dictItem in dataMain["frcChampionships"]:
                         for keys, value in dictItem.items():
@@ -381,13 +381,13 @@ class FirstFRCV7(commands.Cog):
             ) as r:
                 data = await r.content.read()
                 dataMain = orjson.loads(data)
-                filter = ["teams", "description"]
+                filterEventSchedule = ["teams", "description"]
                 embedVar = discord.Embed()
                 embedError = discord.Embed()
                 try:
                     for dictItem in dataMain["Schedule"]:
                         for key, value in dictItem.items():
-                            if key not in filter:
+                            if key not in filterEventSchedule:
                                 embedVar.add_field(
                                     name=key, value=value, inline=True)
                                 embedVar.remove_field(-4)
@@ -430,13 +430,13 @@ class FirstFRCV8(commands.Cog):
             ) as r:
                 data = await r.content.read()
                 dataMain = orjson.loads(data)
-                filter = ["number", "name", "captain", "round1", "round2"]
+                filterEventAlliances = ["number", "name", "captain", "round1", "round2"]
                 embedVar = discord.Embed()
                 embedError = discord.Embed()
                 try:
                     for dictItem in dataMain["Alliances"]:
                         for key, value in dictItem.items():
-                            if key not in filter:
+                            if key not in filterEventAlliances:
                                 embedVar.add_field(
                                     name=key, value=value, inline=True)
                                 embedVar.remove_field(-4)
diff --git a/Bot/Cogs/hypixel.py b/Bot/Cogs/hypixel.py
index 453c758..d5d30ed 100644
--- a/Bot/Cogs/hypixel.py
+++ b/Bot/Cogs/hypixel.py
@@ -37,7 +37,7 @@ class hypixel_api(commands.Cog):
                             title="Player Info",
                             color=discord.Color.from_rgb(186, 244, 255),
                         )
-                        filter = [
+                        filterMainV3 = [
                             "achievements",
                             "achievementsOneTime",
                             "stats",
@@ -59,7 +59,7 @@ class hypixel_api(commands.Cog):
                             "adsense_tokens",
                         ]
                         for key, value in playerMain["player"].items():
-                            if key not in filter:
+                            if key not in filterMainV3:
                                 discord_embed.add_field(
                                     name=key, value=value, inline=True
                                 )
@@ -103,7 +103,6 @@ class hypixel_player_count(commands.Cog):
             ) as response:
                 status = await response.content.read()
                 statusMain = orjson.loads(status)
-                print(statusMain)
                 try:
                     embedVar = discord.Embed(
                         title="Games Player Count",
@@ -201,9 +200,9 @@ class networkPunishments(commands.Cog):
                         color=discord.Color.from_rgb(186, 193, 255),
                     )
                     if str(statsMain["success"]) == "True":
-                        filter = ["success"]
+                        filterMain4 = ["success"]
                         for keys, value in statsMain.items():
-                            if keys not in filter:
+                            if keys not in filterMain4:
                                 embedVar.add_field(
                                     name=keys, value=value, inline=True)
                         await ctx.respond(embed=embedVar)
diff --git a/Bot/Cogs/mcsrvstats.py b/Bot/Cogs/mcsrvstats.py
index 0de07ba..d0f9481 100644
--- a/Bot/Cogs/mcsrvstats.py
+++ b/Bot/Cogs/mcsrvstats.py
@@ -85,8 +85,9 @@ class mcsrvstats(commands.Cog):
                 except Exception as e:
                     embedVar = discord.Embed(color=0xC27C0E)
                     embedVar.description = (
-                        f"Your search for has failed. Please try again.\nReason: {e}"
+                        f"Your search for has failed. Please try again."
                     )
+                    embedVar.add_field(name="Reason", value=e, inline=True)
                     await ctx.respond(embed=embedVar)
 
     asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
@@ -96,8 +97,6 @@ class bedrock_mcsrvstats(commands.Cog):
     def __init__(self, bot):
         self.bot = bot
 
-    ()
-
     @slash_command(
         name="bedrock",
         description="Returns info about the given Minecraft Bedrock server",
@@ -161,8 +160,9 @@ class bedrock_mcsrvstats(commands.Cog):
                 except Exception as e:
                     embedVar = discord.Embed(color=0x607D8B)
                     embedVar.description = (
-                        f"Your search has failed. Please try again.\nReason: {e}"
+                        f"Your search has failed. Please try again."
                     )
+                    embedVar.add_field(name="Reason", value=e, inline=True)
                     await ctx.respond(embed=embedVar)
 
     asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
diff --git a/Bot/Cogs/qrcode.py b/Bot/Cogs/qrcode.py
index 93f9f68..a143163 100644
--- a/Bot/Cogs/qrcode.py
+++ b/Bot/Cogs/qrcode.py
@@ -1,50 +1,50 @@
-import asyncio
-import os
-
-import discord
-import discord.ext
-import qrcode
-import uvloop
-from discord.commands import slash_command
-from discord.ext import commands
-
-
-class qrcode_maker(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="qrcode",
-        description="Creates a QR Code based on given input",
-        guild_ids=[866199405090308116],
-    )
-    async def code(self, ctx, *, link: str):
-        os.chdir(os.path.dirname(os.path.abspath(__file__)))
-        if str(os.path.isfile("/qrcode/qrcode.png")) == "False":
-            img = qrcode.make(link)
-            img.save("./qrcode/qrcode.png")
-        else:
-            img = qrcode.make(link)
-            img.save("./qrcode/qrcode.png")
-        file = discord.File("./qrcode/qrcode.png")
-        embedVar = discord.Embed()
-        embedVar.set_image(url="attachment://qrcode.png")
-        await ctx.send(embed=embedVar, file=file)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-    @code.error
-    async def on_message_error(
-        self, ctx: commands.Context, error: commands.CommandError
-    ):
-        if isinstance(error, commands.MissingRequiredArgument):
-            embedVar = discord.Embed(color=discord.Color.from_rgb(255, 51, 51))
-            embedVar.description = f"Missing a required argument: {error.param}"
-            msg = await ctx.send(embed=embedVar, delete_after=10)
-            await msg.delete(delay=10)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-def setup(bot):
-    bot.add_cog(qrcode_maker(bot))
+import asyncio
+import os
+
+import discord
+import discord.ext
+import qrcode
+import uvloop
+from discord.commands import slash_command
+from discord.ext import commands
+
+
+class qrcode_maker(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="qrcode",
+        description="Creates a QR Code based on given input",
+        guild_ids=[866199405090308116],
+    )
+    async def code(self, ctx, *, link: str):
+        os.chdir(os.path.dirname(os.path.abspath(__file__)))
+        if str(os.path.isfile("/qrcode/qrcode.png")) == "False":
+            img = qrcode.make(link)
+            img.save("./qrcode/qrcode.png")
+        else:
+            img = qrcode.make(link)
+            img.save("./qrcode/qrcode.png")
+        file = discord.File("./qrcode/qrcode.png")
+        embedVar = discord.Embed()
+        embedVar.set_image(url="attachment://qrcode.png")
+        await ctx.respond(embed=embedVar, file=file)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+    @code.error
+    async def on_message_error(
+        self, ctx: commands.Context, error: commands.CommandError
+    ):
+        if isinstance(error, commands.MissingRequiredArgument):
+            embedVar = discord.Embed(color=discord.Color.from_rgb(255, 51, 51))
+            embedVar.description = f"Missing a required argument: {error.param}"
+            msg = await ctx.send(embed=embedVar, delete_after=10)
+            await msg.delete(delay=10)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+def setup(bot):
+    bot.add_cog(qrcode_maker(bot))
diff --git a/Bot/Cogs/reddit.py b/Bot/Cogs/reddit.py
index 8791124..c98fee6 100644
--- a/Bot/Cogs/reddit.py
+++ b/Bot/Cogs/reddit.py
@@ -1,343 +1,341 @@
-import asyncio
-import os
-import random
-
-import asyncpraw
-import discord
-import uvloop
-from discord.commands import Option, slash_command
-from discord.ext import commands
-from dotenv import load_dotenv
-
-load_dotenv()
-
-# Replaced the old user input based auth with a more secure env var based auth
-# Make sure you have this stored at the same directory as the rinbot file within a .env file
-Reddit_ID = os.getenv("Reddit_ID")
-Reddit_Secret = os.getenv("Reddit_Secret")
-
-
-class reddit(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit",
-        description="Searches on reddit for content",
-        guild_ids=[866199405090308116],
-    )
-    async def reddit(
-        self,
-        ctx,
-        *,
-        search: Option(
-            str,
-            "The query you want to search. Also supports searching subreddits as well",
-        ),
-    ):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as api:
-            original_search = search
-            try:
-                if "r/" in search:
-                    search = search.split("/")
-                    sub = search[1]
-                    search = "all"
-                else:
-                    sub = "all"
-                sub = await api.subreddit(sub)
-                searcher = sub.search(query=search)
-                posts = [
-                    post
-                    async for post in searcher
-                    if ".jpg" in post.url
-                    or ".png" in post.url
-                    or ".gif" in post.url
-                    and not post.over_18
-                ]
-                post = random.choice(posts)
-                submission = post
-                reddit_embed = discord.Embed(
-                    color=discord.Color.from_rgb(255, 69, 0))
-                reddit_embed.description = f"{self.bot.user.name} found this post in r/{submission.subreddit.display_name} by {submission.author.name} when searching {original_search}"
-                reddit_embed.set_image(url=submission.url)
-                await ctx.respond(embed=reddit_embed)
-            except Exception as e:
-                embed = discord.Embed()
-                embed.description = f"There was an error, this is likely caused by a lack of posts found in the query {original_search}. Please try again."
-                embed.add_field(name="Reason", value=e, inline=True)
-                await ctx.respond(embed=embed)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-class RedditV2(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit-new",
-        description="Returns 5 new posts from any subreddit",
-        guild_ids=[866199405090308116],
-    )
-    async def redditNew(
-        self, ctx, *, subreddit: Option(str, "The subreddit to search")
-    ):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as redditapi:
-            if "r/" in subreddit:
-                subParser = subreddit.split("/")
-                sub = subParser[1]
-            else:
-                sub = subreddit
-            mainSub = await redditapi.subreddit(sub)
-            async for submission in mainSub.new(limit=5):
-                await submission.author.load()
-                embedVar = discord.Embed()
-                embedVar.title = submission.title
-                embedVar.description = submission.selftext
-                embedVar.add_field(
-                    name="Author", value=submission.author, inline=True)
-                embedVar.add_field(
-                    name="Locked", value=submission.locked, inline=True)
-                embedVar.add_field(
-                    name="NSFW", value=submission.over_18, inline=True)
-                embedVar.add_field(
-                    name="Number of Upvotes", value=submission.score, inline=True
-                )
-                embedVar.add_field(
-                    name="Spoiler", value=submission.spoiler, inline=True
-                )
-                embedVar.add_field(
-                    name="Number of Comments",
-                    value=submission.num_comments,
-                    inline=True,
-                )
-                embedVar.set_image(url=submission.url)
-                embedVar.set_thumbnail(url=submission.author.icon_img)
-                await ctx.respond(embed=embedVar)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-class RedditV3(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit-comments",
-        description="Returns up to 10 comments from a given post ID",
-        guild_ids=[866199405090308116],
-    )
-    async def redditComments(self, ctx, *, id: Option(str, "ID of post")):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as api:
-            post = await api.submission(id=id)
-            comments = await post.comments()
-            listedComments = await comments.list()
-            embedVar = discord.Embed()
-            for item in comments:
-                if len(listedComments) > 10:
-                    return
-                else:
-                    await item.author.load()
-                    embedVar.title = item.author.name
-                    embedVar.description = item.body
-                    embedVar.add_field(
-                        name="Upvotes", value=item.score, inline=True)
-                    embedVar.set_thumbnail(url=item.author.icon_img)
-                    embedVar.remove_field(1)
-                    await ctx.respond(embed=embedVar)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-class RedditV4(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit-user",
-        description="Provides info about the given Redditor",
-        guild_ids=[866199405090308116],
-    )
-    async def redditor(self, ctx, *, redditor: Option(str, "The name of the Redditor")):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as redditorApi:
-            user = await redditorApi.redditor(redditor)
-            await user.load()
-            embedVar = discord.Embed()
-            embedVar.title = user.name
-            embedVar.set_thumbnail(url=user.icon_img)
-            embedVar.add_field(
-                name="Comment Karma", value=user.comment_karma, inline=True
-            )
-            embedVar.add_field(name="Created UTC",
-                               value=user.created_utc, inline=True)
-            embedVar.add_field(name="Link Karma",
-                               value=user.link_karma, inline=True)
-            await ctx.respond(embed=embedVar)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-class RedditV5(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit-user-comments",
-        description="Returns up to 10 comments from a given Redditor",
-        guild_ids=[866199405090308116],
-    )
-    async def redditorComments(
-        self, ctx, *, redditor: Option(str, "The name of the Redditor")
-    ):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as redditorCommentsAPI:
-            userComment = await redditorCommentsAPI.redditor(redditor)
-            embedVar = discord.Embed()
-            async for comment in userComment.comments.new(limit=10):
-                await comment.author.load()
-                embedVar.title = comment.author.name
-                embedVar.description = comment.body
-                embedVar.add_field(
-                    name="Score", value=comment.score, inline=True)
-                embedVar.add_field(
-                    name="Created UTC", value=comment.created_utc, inline=True
-                )
-                embedVar.add_field(name="ID", value=comment.id, inline=True)
-                embedVar.set_thumbnail(url=comment.author.icon_img)
-                embedVar.remove_field(-3)
-                await ctx.respond(embed=embedVar)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-class RedditV6(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit-hot",
-        description="Returns 5 hot posts from any subreddit",
-        guild_ids=[866199405090308116],
-    )
-    async def redditNew(
-        self, ctx, *, subreddit: Option(str, "The subreddit to search")
-    ):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as redditapi:
-            if "r/" in subreddit:
-                subParser = subreddit.split("/")
-                sub = subParser[1]
-            else:
-                sub = subreddit
-            mainSub = await redditapi.subreddit(sub)
-            async for submission in mainSub.hot(limit=5):
-                await submission.author.load()
-                embedVar = discord.Embed()
-                embedVar.title = submission.title
-                embedVar.description = submission.selftext
-                embedVar.add_field(
-                    name="Author", value=submission.author, inline=True)
-                embedVar.add_field(
-                    name="Locked", value=submission.locked, inline=True)
-                embedVar.add_field(
-                    name="NSFW", value=submission.over_18, inline=True)
-                embedVar.add_field(
-                    name="Number of Upvotes", value=submission.score, inline=True
-                )
-                embedVar.add_field(
-                    name="Spoiler", value=submission.spoiler, inline=True
-                )
-                embedVar.add_field(
-                    name="Number of Comments",
-                    value=submission.num_comments,
-                    inline=True,
-                )
-                embedVar.set_image(url=submission.url)
-                embedVar.set_thumbnail(url=submission.author.icon_img)
-                await ctx.respond(embed=embedVar)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-class RedditV7(commands.Cog):
-    def __init__(self, bot):
-        self.bot = bot
-
-    @slash_command(
-        name="reddit-top",
-        description="Returns 5 top posts from any subreddit",
-        guild_ids=[866199405090308116],
-    )
-    async def redditNew(
-        self, ctx, *, subreddit: Option(str, "The subreddit to search")
-    ):
-        async with asyncpraw.Reddit(
-            client_id=Reddit_ID,
-            client_secret=Reddit_Secret,
-            user_agent="ubuntu:rin:v1.4.0-dev (by /u/No767)",
-        ) as redditapi:
-            if "r/" in subreddit:
-                subParser = subreddit.split("/")
-                sub = subParser[1]
-            else:
-                sub = subreddit
-            mainSub = await redditapi.subreddit(sub)
-            async for submission in mainSub.top(limit=5):
-                await submission.author.load()
-                embedVar = discord.Embed()
-                embedVar.title = submission.title
-                embedVar.description = submission.selftext
-                embedVar.add_field(
-                    name="Author", value=submission.author, inline=True)
-                embedVar.add_field(
-                    name="Locked", value=submission.locked, inline=True)
-                embedVar.add_field(
-                    name="NSFW", value=submission.over_18, inline=True)
-                embedVar.add_field(
-                    name="Number of Upvotes", value=submission.score, inline=True
-                )
-                embedVar.add_field(
-                    name="Spoiler", value=submission.spoiler, inline=True
-                )
-                embedVar.add_field(
-                    name="Number of Comments",
-                    value=submission.num_comments,
-                    inline=True,
-                )
-                embedVar.set_image(url=submission.url)
-                embedVar.set_thumbnail(url=submission.author.icon_img)
-                await ctx.respond(embed=embedVar)
-
-    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
-
-
-def setup(bot):
-    bot.add_cog(reddit(bot))
-    bot.add_cog(RedditV2(bot))
-    bot.add_cog(RedditV3(bot))
-    bot.add_cog(RedditV4(bot))
-    bot.add_cog(RedditV5(bot))
-    bot.add_cog(RedditV6(bot))
-    bot.add_cog(RedditV7(bot))
+import asyncio
+import os
+import random
+
+import asyncpraw
+import discord
+import uvloop
+from discord.commands import Option, slash_command
+from discord.ext import commands
+from dotenv import load_dotenv
+
+load_dotenv()
+
+Reddit_ID = os.getenv("Reddit_ID")
+Reddit_Secret = os.getenv("Reddit_Secret")
+
+
+class RedditV1(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit",
+        description="Searches on reddit for content",
+        guild_ids=[866199405090308116],
+    )
+    async def reddit(
+        self,
+        ctx,
+        *,
+        search: Option(
+            str,
+            "The query you want to search. Also supports searching subreddits as well",
+        ),
+    ):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as api:
+            original_search = search
+            try:
+                if "r/" in search:
+                    search = search.split("/")
+                    sub = search[1]
+                    search = "all"
+                else:
+                    sub = "all"
+                sub = await api.subreddit(sub)
+                searcher = sub.search(query=search)
+                posts = [
+                    post
+                    async for post in searcher
+                    if ".jpg" in post.url
+                    or ".png" in post.url
+                    or ".gif" in post.url
+                    and not post.over_18
+                ]
+                post = random.choice(posts)
+                submission = post
+                reddit_embed = discord.Embed(
+                    color=discord.Color.from_rgb(255, 69, 0))
+                reddit_embed.description = f"{self.bot.user.name} found this post in r/{submission.subreddit.display_name} by {submission.author.name} when searching {original_search}"
+                reddit_embed.set_image(url=submission.url)
+                await ctx.respond(embed=reddit_embed)
+            except Exception as e:
+                embed = discord.Embed()
+                embed.description = f"There was an error, this is likely caused by a lack of posts found in the query {original_search}. Please try again."
+                embed.add_field(name="Reason", value=e, inline=True)
+                await ctx.respond(embed=embed)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+class RedditV2(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit-new",
+        description="Returns 5 new posts from any subreddit",
+        guild_ids=[866199405090308116],
+    )
+    async def redditNew(
+        self, ctx, *, subreddit: Option(str, "The subreddit to search")
+    ):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as redditapi:
+            if "r/" in subreddit:
+                subParser = subreddit.split("/")
+                sub = subParser[1]
+            else:
+                sub = subreddit
+            mainSub = await redditapi.subreddit(sub)
+            async for submission in mainSub.new(limit=5):
+                await submission.author.load()
+                embedVar = discord.Embed()
+                embedVar.title = submission.title
+                embedVar.description = submission.selftext
+                embedVar.add_field(
+                    name="Author", value=submission.author, inline=True)
+                embedVar.add_field(
+                    name="Locked", value=submission.locked, inline=True)
+                embedVar.add_field(
+                    name="NSFW", value=submission.over_18, inline=True)
+                embedVar.add_field(
+                    name="Number of Upvotes", value=submission.score, inline=True
+                )
+                embedVar.add_field(
+                    name="Spoiler", value=submission.spoiler, inline=True
+                )
+                embedVar.add_field(
+                    name="Number of Comments",
+                    value=submission.num_comments,
+                    inline=True,
+                )
+                embedVar.set_image(url=submission.url)
+                embedVar.set_thumbnail(url=submission.author.icon_img)
+                await ctx.respond(embed=embedVar)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+class RedditV3(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit-comments",
+        description="Returns up to 10 comments from a given post ID",
+        guild_ids=[866199405090308116],
+    )
+    async def redditComments(self, ctx, *, post_id: Option(str, "ID of post")):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as api:
+            post = await api.submission(id=post_id)
+            comments = await post.comments()
+            listedComments = await comments.list()
+            embedVar = discord.Embed()
+            for item in comments:
+                if len(listedComments) > 10:
+                    return
+                else:
+                    await item.author.load()
+                    embedVar.title = item.author.name
+                    embedVar.description = item.body
+                    embedVar.add_field(
+                        name="Upvotes", value=item.score, inline=True)
+                    embedVar.set_thumbnail(url=item.author.icon_img)
+                    embedVar.remove_field(1)
+                    await ctx.respond(embed=embedVar)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+class RedditV4(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit-user",
+        description="Provides info about the given Redditor",
+        guild_ids=[866199405090308116],
+    )
+    async def redditor(self, ctx, *, redditor: Option(str, "The name of the Redditor")):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as redditorApi:
+            user = await redditorApi.redditor(redditor)
+            await user.load()
+            embedVar = discord.Embed()
+            embedVar.title = user.name
+            embedVar.set_thumbnail(url=user.icon_img)
+            embedVar.add_field(
+                name="Comment Karma", value=user.comment_karma, inline=True
+            )
+            embedVar.add_field(name="Created UTC",
+                               value=user.created_utc, inline=True)
+            embedVar.add_field(name="Link Karma",
+                               value=user.link_karma, inline=True)
+            await ctx.respond(embed=embedVar)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+class RedditV5(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit-user-comments",
+        description="Returns up to 10 comments from a given Redditor",
+        guild_ids=[866199405090308116],
+    )
+    async def redditorComments(
+        self, ctx, *, redditor: Option(str, "The name of the Redditor")
+    ):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as redditorCommentsAPI:
+            userComment = await redditorCommentsAPI.redditor(redditor)
+            embedVar = discord.Embed()
+            async for comment in userComment.comments.new(limit=10):
+                await comment.author.load()
+                embedVar.title = comment.author.name
+                embedVar.description = comment.body
+                embedVar.add_field(
+                    name="Score", value=comment.score, inline=True)
+                embedVar.add_field(
+                    name="Created UTC", value=comment.created_utc, inline=True
+                )
+                embedVar.add_field(name="ID", value=comment.id, inline=True)
+                embedVar.set_thumbnail(url=comment.author.icon_img)
+                embedVar.remove_field(-3)
+                await ctx.respond(embed=embedVar)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+class RedditV6(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit-hot",
+        description="Returns 5 hot posts from any subreddit",
+        guild_ids=[866199405090308116],
+    )
+    async def redditNew(
+        self, ctx, *, subreddit: Option(str, "The subreddit to search")
+    ):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as redditapi:
+            if "r/" in subreddit:
+                subParser = subreddit.split("/")
+                sub = subParser[1]
+            else:
+                sub = subreddit
+            mainSub = await redditapi.subreddit(sub)
+            async for submission in mainSub.hot(limit=5):
+                await submission.author.load()
+                embedVar = discord.Embed()
+                embedVar.title = submission.title
+                embedVar.description = submission.selftext
+                embedVar.add_field(
+                    name="Author", value=submission.author, inline=True)
+                embedVar.add_field(
+                    name="Locked", value=submission.locked, inline=True)
+                embedVar.add_field(
+                    name="NSFW", value=submission.over_18, inline=True)
+                embedVar.add_field(
+                    name="Number of Upvotes", value=submission.score, inline=True
+                )
+                embedVar.add_field(
+                    name="Spoiler", value=submission.spoiler, inline=True
+                )
+                embedVar.add_field(
+                    name="Number of Comments",
+                    value=submission.num_comments,
+                    inline=True,
+                )
+                embedVar.set_image(url=submission.url)
+                embedVar.set_thumbnail(url=submission.author.icon_img)
+                await ctx.respond(embed=embedVar)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+class RedditV7(commands.Cog):
+    def __init__(self, bot):
+        self.bot = bot
+
+    @slash_command(
+        name="reddit-top",
+        description="Returns 5 top posts from any subreddit",
+        guild_ids=[866199405090308116],
+    )
+    async def redditNew(
+        self, ctx, *, subreddit: Option(str, "The subreddit to search")
+    ):
+        async with asyncpraw.Reddit(
+            client_id=Reddit_ID,
+            client_secret=Reddit_Secret,
+            user_agent="ubuntu:rin:v2.0.0 (by /u/No767)",
+        ) as redditapi:
+            if "r/" in subreddit:
+                subParser = subreddit.split("/")
+                sub = subParser[1]
+            else:
+                sub = subreddit
+            mainSub = await redditapi.subreddit(sub)
+            async for submission in mainSub.top(limit=5):
+                await submission.author.load()
+                embedVar = discord.Embed()
+                embedVar.title = submission.title
+                embedVar.description = submission.selftext
+                embedVar.add_field(
+                    name="Author", value=submission.author, inline=True)
+                embedVar.add_field(
+                    name="Locked", value=submission.locked, inline=True)
+                embedVar.add_field(
+                    name="NSFW", value=submission.over_18, inline=True)
+                embedVar.add_field(
+                    name="Number of Upvotes", value=submission.score, inline=True
+                )
+                embedVar.add_field(
+                    name="Spoiler", value=submission.spoiler, inline=True
+                )
+                embedVar.add_field(
+                    name="Number of Comments",
+                    value=submission.num_comments,
+                    inline=True,
+                )
+                embedVar.set_image(url=submission.url)
+                embedVar.set_thumbnail(url=submission.author.icon_img)
+                await ctx.respond(embed=embedVar)
+
+    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
+
+
+def setup(bot):
+    bot.add_cog(RedditV1(bot))
+    bot.add_cog(RedditV2(bot))
+    bot.add_cog(RedditV3(bot))
+    bot.add_cog(RedditV4(bot))
+    bot.add_cog(RedditV5(bot))
+    bot.add_cog(RedditV6(bot))
+    bot.add_cog(RedditV7(bot))
diff --git a/Bot/Cogs/rininfo.py b/Bot/Cogs/rininfo.py
index 321868c..9be3dcc 100644
--- a/Bot/Cogs/rininfo.py
+++ b/Bot/Cogs/rininfo.py
@@ -31,7 +31,7 @@ class info(commands.Cog):
         embedVar.set_author(name="Rin Info", icon_url=bot.user.display_avatar)
         embedVar.add_field(
             name="About",
-            value="Rin is a Discord bot focused on providing data from third party services such as DeviantArt, Hypixel, Reddit, MyAnimeList/Jikan, and many others with the advantage of speed. Rin allows you to find memes on Reddit with the Reddit service, or get info about your favorite anime with the MAL service. Under the hood, Rin uses [Uvloop](https://github.com/MagicStack/uvloop), which is 2x faster than Node.js and has the same performance as many Go programs. If you want a multipurpose version of Rin, check out Kumiko.",
+            value="Rin is a Discord bot focused on providing data from third party services such as DeviantArt, Hypixel, Reddit, MyAnimeList/Jikan, and many others with lighting speed. Rin allows you to find memes on Reddit with the Reddit service, or get info about your favorite anime with the MAL service. Under the hood, Rin uses [Uvloop](https://github.com/MagicStack/uvloop), which is 2x faster than Node.js and has the same performance as many Go programs. If you want a multipurpose version of Rin, check out Kumiko.",
             inline=False,
         )
         embedVar.add_field(
diff --git a/Bot/Cogs/spiget.py b/Bot/Cogs/spiget.py
index 82b2127..a6e4550 100644
--- a/Bot/Cogs/spiget.py
+++ b/Bot/Cogs/spiget.py
@@ -41,7 +41,7 @@ class SpigetV2(commands.Cog):
                         download_url_external_false = "https://spigotmc.org/" + str(
                             dictItem["file"]["url"]
                         )
-                        filter = [
+                        filterMain6 = [
                             "icon",
                             "links",
                             "releaseDate",
@@ -65,7 +65,7 @@ class SpigetV2(commands.Cog):
                             )
                             embedVar.description = dictItem["tag"]
                             for key, value in dictItem.items():
-                                if key not in filter:
+                                if key not in filterMain6:
                                     embedVar.add_field(
                                         name=key, value=value, inline=True
                                     )
diff --git a/Bot/Cogs/top-gg.py b/Bot/Cogs/top-gg.py
index 89acfce..b122211 100644
--- a/Bot/Cogs/top-gg.py
+++ b/Bot/Cogs/top-gg.py
@@ -54,8 +54,9 @@ class TopGGV1(commands.Cog):
                     embedVar = discord.Embed(
                         color=discord.Color.from_rgb(231, 74, 255))
                     embedVar.description = (
-                        f"The query failed. Please try again.\nReason: {e}"
+                        f"The query failed. Please try again."
                     )
+                    embedVar.add_field(name="Reason", value=e, inline=True)
                     await ctx.respond(embed=embedVar)
 
     asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
@@ -108,8 +109,9 @@ class TopGGV2(commands.Cog):
                     embedVar = discord.Embed(
                         color=discord.Color.from_rgb(231, 74, 255))
                     embedVar.description = (
-                        f"The query failed. Please try again.\nReason: {e}"
+                        f"The query failed. Please try again."
                     )
+                    embedVar.add_field(name="Reason", value=e, inline=True)
                     await ctx.respond(embed=embedVar)
 
     asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
diff --git a/Bot/Cogs/version.py b/Bot/Cogs/version.py
index d11f7a2..d1d4c4e 100644
--- a/Bot/Cogs/version.py
+++ b/Bot/Cogs/version.py
@@ -17,7 +17,7 @@ class VersionV1(commands.Cog):
     )
     async def version(self, ctx):
         embedVar = discord.Embed()
-        embedVar.description = "Build Version: v2.0.0-rc1"
+        embedVar.description = "Build Version: v2.0.0"
         await ctx.respond(embed=embedVar)
 
     asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
diff --git a/Bot/Cogs/waifu-pics.py b/Bot/Cogs/waifu-pics.py
index f6b2338..ad141a2 100644
--- a/Bot/Cogs/waifu-pics.py
+++ b/Bot/Cogs/waifu-pics.py
@@ -56,9 +56,9 @@ class waifuPics(commands.Cog):
         async with aiohttp.ClientSession(json_serialize=orjson.dumps) as session:
             async with session.get(f"https://api.waifu.pics/sfw/{searchterm}") as r:
                 waifu_pics = await r.content.read()
-                orjson.loads(waifu_pics)
+                waifu_pics_main = orjson.loads(waifu_pics)
                 try:
-                    await ctx.respond(waifu_picsMain["url"])
+                    await ctx.respond(waifu_pics_main["url"])
                 except Exception as e:
                     embedVar = discord.Embed()
                     embedVar.description = "The query was not successful"
diff --git a/Bot/Cogs/youtube.py b/Bot/Cogs/youtube.py
index 7b14545..afd48fe 100644
--- a/Bot/Cogs/youtube.py
+++ b/Bot/Cogs/youtube.py
@@ -118,7 +118,7 @@ class YoutubeV2(commands.Cog):
                         embedVar = discord.Embed(
                             color=discord.Color.from_rgb(255, 0, 0)
                         )
-                        filter = {"kind", "etag", "snippet",
+                        filterMain5 = {"kind", "etag", "snippet",
                                   "statistics", "localized"}
                         snippetFilter = [
                             "title",
@@ -128,7 +128,7 @@ class YoutubeV2(commands.Cog):
                         ]
                         for dictItem in dataMain3["items"]:
                             for key, val in dictItem.items():
-                                if key not in filter:
+                                if key not in filterMain5:
                                     embedVar.add_field(
                                         name=key, value=val, inline=True)
                             for k, v in dictItem["snippet"].items():
@@ -302,7 +302,7 @@ class YoutubeV4(commands.Cog):
                             "canRate",
                             "id",
                             "authorChannelUrl",
-                            "videoId",
+                            "videoId"
                         ]
                         pfpFilter = [
                             "videoId",
diff --git a/Bot/rinbot.py b/Bot/rinbot.py
index 8b83ccb..94f1e85 100644
--- a/Bot/rinbot.py
+++ b/Bot/rinbot.py
@@ -6,7 +6,7 @@ from dotenv import load_dotenv
 
 # Grabs the bot's token from the .env file
 load_dotenv()
-TOKEN = os.getenv("Hanako_Token")
+TOKEN = os.getenv("TOKEN")
 intents = Intents.all()
 bot = commands.Bot(command_prefix=".", help_command=None)
 
@@ -40,6 +40,7 @@ initial_extensions = [
     "Cogs.modrinth",
     "Cogs.discord-bots",
     "Cogs.first-frc-events",
+    "Cogs.deviantart",
 ]
 for extension in initial_extensions:
     bot.load_extension(extension)
-- 
2.35.1

